[TOC]

## 第一部分

附件8是“设计显示一个UI界面中包含的几何图形元素”的C++例子，其中提供了组合和继承两种设计，主调测试程序为TestUI.cpp。请分别分析这两种设计，如果需求改变，如给界面中增加圆形元素，请分别按组合和抽象设计方法增加这个功能。对比所需修改的部分，分析哪种设计修改量少、通用性高、更适用于软件复用？ 组合与继承哪种方法更能体现面向对象的核心思想：抽象？

>客户需求变化 ：
>如果客户要求给界面中增加圆形元素，请分别按组合和继承设计方法增加这个功能。对比所需修改的部分，分析哪种设计修改量少、通用性高、更适用于软件复用？如果未来再增加其他图形呢？

### 对于组合 : 

修改如下 :

添加Circle.hpp 定义圆形元素

```c++
#ifndef __Circle__
#define __Circle__
#include "Point.h"
#include <iostream>
class Circle{
private :
    Point center;
    double radius;
public :
    Circle(const Point & A, float r) {
        center = A;
        radius = r;
    }
    void show() {
        std::cout << "Circle : (" << center.getX() << "," << center.getY() << " ) r = " << radius << std::endl; 
    }
    Point getCenter() {
        return center;
    }
    double getRadius() {
        return radius;
    }
};
#endif
```

在testUI.cpp中添加以下代码 , 用来测试圆类型

```c++
	Circle circle(p1, 5);
	ui.circleVector.push_back(circle);
```

在UI.h中做以下修改 , 用来在UI中增加圆类型

```c++
// ------省略------
#include "Circle.hpp"
//类的组合
class UI{   //用户界面，组合类 
    public:
    // ------省略------
    vector<Circle> circleVector;
	void show(){
		// ------省略------
		for (auto & i : circleVector) {
			i.show();
		}
	}
};
```

测试结果如下

![image-20210521124145581](C:\Users\yqy\AppData\Roaming\Typora\typora-user-images\image-20210521124145581.png)

### 对于继承

添加Circle.hpp , 定义圆类型

```c++
#ifndef __Circle__
#define __Circle__
#include "Shape.h"
#include "Point.h"
#include <iostream>
class Circle : public Shape{
private :
    Point center;
    double radius;
public :
    Circle(const Point & A, float r) {
        center = A;
        radius = r;
    }
    virtual void show() {
        std::cout << "Circle : (" << center.getX() << "," << center.getY() << " ) r = " << radius << std::endl; 
    }
    Point getCenter() {
        return center;
    }
    double getRadius() {
        return radius;
    }
};
#endif
```

在testUI.cpp做以下修改

```c++
//测试设计主调程序 
// ------省略------
#include "Circle.hpp"
#include "UI.h"

main(){ 
	UI ui;
    // ------省略------
    ui.shapeVector.push_back(new Circle(p1, 5));
    ui.show();
}
```

测试结果 : 

![image-20210521124734454](C:\Users\yqy\AppData\Roaming\Typora\typora-user-images\image-20210521124734454.png)

详细代码可以在当前目录下inherit文件夹和composite文件夹下找到

### 问题解答

分析哪种设计修改量少、通用性高、更适用于软件复用？ 如果未来再增加其他图形呢？组合与继承哪种方法更能体现面向对象的核心思想：抽象？

第二种 , 继承的方式修改量少 , 通用性高. 组合的方式更适用于软件复用 . 如果未来在增加其他图形 , 继承也只需要添加一个文件继承Shape类 , 不需要修改UI. 相比之下组合要修改很多文件.

继承更能体现出抽象的思想 , 对所有的图形抽象出来Shape类

## 第二部分

实现图6-13中的 Engineer与Software Engineer的两种设计实例，并进行讨论。如果要利用组合来实现可替换性，需要怎样设计？

类继承 : 

SoftwareEngineer继承Engineer

```c++
class Engineer{
private :
    bool someThing;
public : 

};

class SoftwareEngineer : public Engineer{
private :

public : 

};
```

组合 :

SoftwareEngineer有一个engCapabilities子类 , 该类指向Engineer;

```c++
class Engineer{
private :

public : 

};

class engCapabilities {
private : 
    Engineer *test;
public : 
    engCapabilities(Engineer *x) {
        test = x;
    }
};

class SoftwareEngineer{
private :
    engCapabilities *ability;
public : 
    SoftwareEngineer(Engineer *ability) {
        this->ability = new engCapabilities(ability);
    }
};
```

讨论 :



利用组合来实现可替换性 : 

抽象一个Ability类 , Engineer类继承Ability类 . engCapabilities指向Ability类型 , 传参只需要传Ability类型的指针即可 , 如果要替换则继承Ability类即可.

```c++
class Ability {

};
class Engineer : public Ability{

};

class engCapabilities {
private : 
    Ability *test;
public : 
    engCapabilities(Ability *x) {
        test = x;
    }
};

class SoftwareEngineer{
private :
    engCapabilities *ability;
public : 
    SoftwareEngineer(Ability *ability) {
        this->ability = new engCapabilities(ability);
    }
};
 
int main() {
    Engineer x;
    SoftwareEngineer y(&x);
}
```

